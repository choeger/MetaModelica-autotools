Each port is supposed to have a "config.h" file, in which
OS, CPU, and compiler dependencies are taken care of.

"config.h" will contain a number of constant #defines,
feature #defines, and typedefs. In general, the constants
and typedefs must always be included. The allowable
combinations of feature #defines are described below.
It is not necessary to #undef inappropriate features.

The "repchk" tool can often be used to automatically generate
declarations for representation dependencies. It will also
attempt to check other basic assumptions made by the code.
(Should it fail to compile or execute, then that is a strong
indication that RML cannot easily be ported to the platform.)

/* The following declarations can be generated by "repchk".
 */

/* Signed and unsigned versions of a suitable integral
 * type (a "word") capable of holding any pointer. The
 * type must be int or long. Both typedefs are mandatory.
 */
typedef ???		rml_sint_t;
typedef unsigned ???	rml_uint_t;

/* Pre-processing time constants describing the sizes, in
 * bytes, of the word and double types. RML_SIZE_DBL must be
 * RML_SIZE_INT or 2*RML_SIZE_INT. All three are mandatory.
 */
#define RML_LOG2_SIZE_INT	?
#define RML_SIZE_INT		?
#define RML_SIZE_DBL		?

/* Define this if the compiler puts any padding between
 * x and y in "struct { rml_uint_t x; double y; }".
 */
#define RML_DBL_PAD

/* The runtime system guarantees only word alignment of doubles.
 * Define this symbol if accesses via "double*" _require_ double
 * alignment for correct execution. Do not define it if a word
 * aligned access just costs a few more cycles.
 */
#define RML_DBL_STRICT

/* Define this if your C stack grows towards higher addresses.
 * Only the PUSHY runtime cares about it.
 */
#define RML_STACK_GROWS_POSITIVE

/* End of declarations that "repchk" can generate.
 * From now on, you're on your own..
 */

/* Timing facility. Define EXACTLY ONE of these.
 */
#define RML_CLOCK_RUSAGE	/* for getrusage() */
#define	RML_CLOCK_TIMES		/* for times() */
#define RML_CLOCK_PARIX		/* for Parix' TimeNow() */
#define RML_CLOCK_ANSIC		/* for plain ANSI-C clock() */

/* How to gain access to a working alloca().
 * The PUSHY runtime system requires exactly one of these to
 * be defined. The other runtime systems do not use alloca().
 * Emulations on top of malloc() are prohibited.
 */
#define RML_ALLOCA_H		/* use <alloca.h> */
#define	RML_ALLOCA_BUILTIN	/* use __builtin_alloca */
#define RML_ALLOCA_EMULATE	/* use our own emulation */

/* The fastest way to perform setjmp and longjmp.
 * Some implementations save and restore signal masks,
 * but also have cheaper alternatives.
 * Only the PUSHY runtime really cares about this.
 */
#define rml_setjmp	?	/* usually setjmp() or _setjmp() */
#define rml_longjmp	?	/* usually longjmp() or _longjmp() */

/* Preferred size, in words, of the youngest generation
 * (a.k.a. nursery or allocation arena) in the heap. The
 * preferred size may be dependent on which runtime system
 * we are building; this is indicated by one of the symbols
 * RML_PLAIN, RML_SWITCH, or RML_PUSHY being defined. In the
 * PUSHY runtime, this will be the size of the stack buffer.
 */
#ifdef	RML_PLAIN
#define RML_YOUNG_SIZE	(???*1024)
#endif
#ifdef	RML_SWITCH
#define RML_YOUNG_SIZE	(???*1024)
#endif
#ifdef	RML_PUSHY
#define RML_YOUNG_SIZE	(???*1024)
#endif
#endif

/* Preferred access method for the global RML state variables.
 * This is used by the RML_PLAIN and RML_SWITCH runtime systems.
 * Again, the choice may depend on which runtime we're building.
 * There are four allowable configurations:
 * 1. If none of the symbols are defined, the state variables will
 * be placed in separate global variables.
 * 2. If RML_STATE_JOIN is defined, the state variables will be
 * placed in a single global struct.
 * 3. If RML_STATE_JOIN and RML_STATE_APTR are defined, the address
 * of the struct will be passed as an argument to functions.
 * 4. If RML_STATE_JOIN and RML_STATE_LPTR are defined, each
 * function will bind a local variable to the address of the struct.
 */
#ifdef RML_PLAIN
#define RML_STATE_JOIN
#define RML_STATE_APTR
#define RML_STATE_LPTR
#endif
#ifdef RML_SWITCH
#define RML_STATE_JOIN
#define RML_STATE_APTR
#define RML_STATE_LPTR
#endif

/* Preferred way to implement unknown gotos in the SWITCH runtime.
 * There are three allowable configurations:
 * 1. None of the symbols are defined.
 * 2. RML_GCCGOTO is defined.
 * 3. RML_GCCGOTO and RML_GCCGOTO_NOSHIFT are defined.
 * RML_GCCGOTO means to use gcc's first-class labels, by storing
 * local labels in a table and dispatching via a table reference.
 * RML_GCCGOTO_NOSHIFT means to use a byte pointer to the table and to
 * pre-scale table indices so that no scaling is performed at runtime.
 */
#define RML_GCCGOTO
#define RML_GCCGOTO_NOSHIFT

/* End of "config.h" parameters.
 */
